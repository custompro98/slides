<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <title>LnL GraphQL</title>
        <meta name="description" content="This presentation is generated by vim-reveal and reveal.js.">
        <meta name="author" content="author">
        <meta name="apple-mobile-web-app-capable" content="yes" />
        <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
        <link rel="stylesheet" href="../../css/reveal.css">
        <link rel="stylesheet" href="../../css/theme/solarized.css" id="theme">
        <link rel="stylesheet" href="../../lib/css/zenburn.css">
        <!-- If the query includes 'print-pdf', use the PDF print sheet -->
        <script>
            document.write( '<link rel="stylesheet" href="../../css/print/' + ( window.location.search.match( /print-pdf/gi ) ? 'pdf' : 'paper' ) + '.css" type="text/css" media="print">' );
        </script>
        <!--[if lt IE 9]>
        <script src="../../lib/js/html5shiv.js"></script>
        <![endif]-->
    </head>

    <body>
        <div class="reveal">
            <div class="slides">

<section>
<section data-markdown >
<script type="text/template">
# GraphQL and Chill

</script>
</section>
<section data-markdown >
<script type="text/template">
Before we get into it we need to know

</script>
</section>
<section data-markdown >
<script type="text/template">
## What is GraphQL?

</script>
</section>
<section data-markdown >
<script type="text/template">
## A Query Language for Your API*
An API design spec meant to facilitate only selecting data you need

NOTE: I put an asterisk here because the query language part is really secondary.

</script>
</section>
<section data-markdown >
<script type="text/template">
Primarily it organizes your data as a graph

NOTE: If you take away one thing from this lunch and learn, it should be this

</script>
</section>
<section data-markdown >
<script type="text/template">
The consumer shouldn't think of your API as an application they need to interface with, but as a pile of data at its disposal

NOTE: For example, Relay (GraphQL & React) wants you to treat your API as your data store

</script>
</section>
</section>
<section>
<section data-markdown >
<script type="text/template">
## What makes it a Query Language?

</script>
</section>
<section data-markdown >
<script type="text/template">
Instead of passing params to a specific endpoint to determine the shape of results, you specify the shape directly to a single endpoint

</script>
</section>
<section data-markdown >
<script type="text/template">
```json
query {
  users {
    posts {
      title
      content
    }
  }
}
```

NOTE: This is a general structure of a query
Query tells the API we're looking up data
A field is what tells the API what fields to get back
QUESTION: What are fields in this query?

</script>
</section>
</section>
<section>
<section data-markdown >
<script type="text/template">
## What makes it a Graph?

</script>
</section>
<section data-markdown >
<script type="text/template">
REST has nested objects
```json
users: [
  ...,
  posts: [
    ...
  ]
]
```

</script>
</section>
<section data-markdown >
<script type="text/template">
Where GraphQL has connections

```json
users: [
  ...,
  authoredPosts: {
    totalCount: 10,
    edges {
      authoredOn,
      node {
        title,
        content
      }
    }
  }
]
```

NOTE: think about edges as the relationship to the other object.
These edges contain metadata about the nodes
i.e. A user _authored_ a post, so the edge "authored" connects nodes "user" and "post" and would know when the event occurred

</script>
</section>
<section data-markdown >
<script type="text/template">
The REST version looks smaller, but the GraphQL version better illustrates relationships among data

</script>
</section>
<section data-markdown >
<script type="text/template">
![graph](images/graph.png)

NOTE: This is called the viewer pattern, the idea is that the user is the entry point of the graph.
Connections just follow the edges on the graph

</script>
</section>
</section>
<section>
<section data-markdown >
<script type="text/template">
## Why REST?

NOTE: REST promised we'd never need to think about how to access our data if we used the right HTTP verb and routes
Everything would make sense
but what's the biggest problem with REST endpoints?

</script>
</section>
<section data-markdown >
<script type="text/template">
## Our endpoints send back too much data!

NOTE: Enter query params...

</script>
</section>
<section data-markdown >
<script type="text/template">
### This is fine
`GET /api/users/posts?include_author=false&include_comments=true`

NOTE: but might not be good enough

</script>
</section>
<section data-markdown >
<script type="text/template">
### This is not fine
`GET /api/users/comments?since=1234567890&include[]=title&include[]=favorite&include[]=author&include[]=comments&...`

</script>
</section>
</section>
<section>
<section data-markdown >
<script type="text/template">
## Why GraphQL?

NOTE: it's easiest to show with an example

</script>
</section>
<section data-markdown >
<script type="text/template">
### Want all of a user's posts? Fine.
```json
query {
  users {
    authoredPosts {
      title
      content
    }
  }
}
```

</script>
</section>
<section data-markdown >
<script type="text/template">
### Want the post's comments and author? Also fine.
```json
query {
  users {
    authoredPosts {
      title
      content
      author {
        first_name
        last_name
        email
      }
      comments {
        content
        author {
          frst_name
          last_name
          email
        }
      }
    }
  }
}
```

</script>
</section>
<section data-markdown >
<script type="text/template">
## It's the same endpoint
`POST /api/graphql`

NOTE: But a consumer can ask for any data they want
You can offer anything and everything, but it won't affect the consumer unless they want it

</script>
</section>
<section data-markdown >
<script type="text/template">
## And the data is where it belongs, in the request body

</script>
</section>
</section>
<section>
<section data-markdown >
<script type="text/template">
## Coexistence

NOTE: REST and GraphQL actually work really well together
for all the talk of "REST-killer" one doesn't have to "kll" the other

</script>
</section>
<section data-markdown >
<script type="text/template">
### Choose what works

NOTE: In the same sense, you can have GraphQL manage the read portion of your API and rely on REST to handle create, update, delete
Or you can have GraphQL handle CRUD while you use REST for auth
It's entirely up to you how far you want to dive in
At the end of the day, choose what works for you
There's no reason you can't have both a GraphQL API and a REST API

</script>
</section>
</section>
<section>
<section data-markdown >
<script type="text/template">
## When to use GraphQL?

</script>
</section>
<section data-markdown >
<script type="text/template">
## When to use GraphQL?
- Your objects can be connected to other objects

</script>
</section>
<section data-markdown >
<script type="text/template">
## When to use GraphQL?
- Your objects can be connected to other objects
- Your consumers don't always want all of the connected objects

</script>
</section>
<section data-markdown >
<script type="text/template">
## When to use GraphQL?
- Your objects can be connected to other objects
- Your consumers don't always want all of the connected objects
- You want to make your consumers happy

</script>
</section>
<section data-markdown >
<script type="text/template">
For further reading on nomenclature:
https://custompro98.github.io/slides/
</script>
</section>
</section>
            </div>
        </div>
        <script src="../../lib/js/head.min.js"></script>
        <script src="../../js/reveal.js"></script>
        <script>
            Reveal.initialize({
                controls: true,
                progress: true,
                history: false,
                keyboard: true,
                touch: true,
                center: true,
                loop: false,
                rtl: false,
                mouseWheel: false,
                margin: 0.1,
                minScale: 0.2,
                maxScale: 1.0,
                autoSlide: 0,
                width: 960,
                height: 900,
                theme: 'solarized',
                transition: 'default',
                transitionSpeed: 'default',
                backgroundTransition: 'default',
                // Optional libraries used to extend on reveal.js
                dependencies: [
                    { src: '../../lib/js/classList.js', condition: function() { return !document.body.classList; } },
                    { src: '../../plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                    { src: '../../plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                    { src: '../../plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
                    { src: '../../plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
                    { src: '../../plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } },
                    { src: '../../plugin/math/math.js', async: true }
                ]
            });
        </script>
    </body>
</html>
